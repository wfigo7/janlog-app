# Janlog バージョン管理ガイド

このドキュメントは、Janlogアプリケーションのバージョン管理ルールとリリースプロセスを定義します。

## 目次

- [セマンティックバージョニング](#セマンティックバージョニング)
- [バージョンインクリメントルール](#バージョンインクリメントルール)
- [サブシステムバージョン管理](#サブシステムバージョン管理)
- [バージョン互換性マトリクス](#バージョン互換性マトリクス)
- [リリースプロセス](#リリースプロセス)
- [ビルド番号管理](#ビルド番号管理)

## セマンティックバージョニング

Janlogは[Semantic Versioning 2.0.0](https://semver.org/)に準拠したバージョン管理を採用しています。

### バージョンフォーマット

```
MAJOR.MINOR.PATCH
```

- **MAJOR**: 破壊的変更（APIの非互換変更、データモデルの大幅変更）
- **MINOR**: 後方互換性のある機能追加
- **PATCH**: 後方互換性のあるバグ修正

### 例

- `0.1.0` - 初期MVPリリース
- `0.2.0` - 新機能追加（プレリリース段階）
- `0.2.1` - バグ修正
- `1.0.0` - 本番準備完了（最初の安定版）
- `1.1.0` - 新機能追加（本番リリース後）
- `2.0.0` - 破壊的変更

## バージョンインクリメントルール

### プレリリース段階（0.x.y）

現在のJanlogはプレリリース段階（MAJORバージョン0）です。

- **MINOR（0.x.0）**: 新機能追加時
- **PATCH（0.x.y）**: バグ修正時
- **MAJOR**: 常に0（本番準備完了まで）

### 本番リリース後（1.x.y以降）

本番準備が完了し、バージョン1.0.0に到達した後：

- **MAJOR（x.0.0）**: 破壊的変更
  - APIの非互換変更
  - データモデルの大幅変更
  - 既存機能の削除
- **MINOR（x.y.0）**: 後方互換性のある機能追加
  - 新しいエンドポイントの追加
  - 新しい画面の追加
  - オプション機能の追加
- **PATCH（x.y.z）**: 後方互換性のあるバグ修正
  - バグ修正
  - パフォーマンス改善
  - セキュリティパッチ

### バージョンインクリメント判断フローチャート

```
変更内容を確認
    ↓
破壊的変更がある？
    ├─ Yes → MAJOR++
    └─ No
        ↓
    新機能追加がある？
        ├─ Yes → MINOR++
        └─ No
            ↓
        バグ修正がある？
            ├─ Yes → PATCH++
            └─ No → バージョン変更なし

※ プレリリース段階（0.x.y）の場合、MAJORは常に0のまま
```

### 判断例

| 変更内容 | プレリリース（0.x.y） | 本番リリース後（1.x.y+） |
|---------|---------------------|----------------------|
| 会場管理機能の追加 | 0.1.0 → 0.2.0 | 1.0.0 → 1.1.0 |
| 対局登録のバグ修正 | 0.1.0 → 0.1.1 | 1.0.0 → 1.0.1 |
| API仕様の非互換変更 | 0.1.0 → 0.2.0 | 1.0.0 → 2.0.0 |
| UIの改善（機能変更なし） | 0.1.0 → 0.1.1 | 1.0.0 → 1.0.1 |

## サブシステムバージョン管理

Janlogは3つのサブシステムで構成されており、それぞれ独立したバージョンを持ちます。

### フロントエンド（frontend/）

**管理ファイル:**
- `frontend/package.json` - npmパッケージバージョン
- `frontend/app.json` - Expoアプリバージョン、ビルド番号

**例:**
```json
// package.json
{
  "name": "@janlog/frontend",
  "version": "0.1.0"
}

// app.json
{
  "expo": {
    "version": "0.1.0",
    "android": {
      "versionCode": 1
    },
    "ios": {
      "buildNumber": "1"
    }
  }
}
```

### バックエンド（backend/）

**管理ファイル:**
- `backend/pyproject.toml` - Pythonプロジェクトバージョン

**例:**
```toml
[project]
name = "janlog-backend"
version = "0.1.0"
description = "Janlog Backend - FastAPI Lambda Application"
```

### インフラストラクチャ（infra/）

**管理ファイル:**
- `infra/package.json` - CDKプロジェクトバージョン

**例:**
```json
{
  "name": "@janlog/infra",
  "version": "0.1.0",
  "description": "Janlog Infrastructure - AWS CDK"
}
```

### アプリケーションバージョンの定義

**アプリケーションバージョン = フロントエンドバージョン**

ユーザー向けのアプリケーションバージョンは、フロントエンドのバージョンと同じです。これは、ユーザーが直接操作するのがフロントエンドアプリケーションであるためです。

## バージョン互換性マトリクス

フロントエンド、バックエンド、インフラの各バージョンの互換性を記録します。

| アプリバージョン | フロントエンド | バックエンド | インフラ | 互換性 | リリース日 | 備考 |
|-----------------|--------------|-------------|---------|--------|-----------|------|
| 0.1.0           | 0.1.0        | 0.1.0       | 0.1.0   | ✅     | 2025-10-17 | 初期MVPリリース、バージョン管理体系確立 |

### 互換性ルール

1. **フロントエンドとバックエンド:**
   - MAJORバージョンが異なる場合は非互換
   - MINORバージョン差は±1まで互換
   - PATCHバージョンは常に互換

2. **インフラバージョン:**
   - フロントエンド・バックエンドとは独立
   - CDK構成の変更を示す
   - アプリケーションの動作には直接影響しない

3. **互換性の例:**
   - ✅ Frontend 0.2.0 + Backend 0.1.0 → 互換
   - ✅ Frontend 0.1.5 + Backend 0.1.0 → 互換
   - ❌ Frontend 1.0.0 + Backend 0.9.0 → 非互換
   - ❌ Frontend 0.3.0 + Backend 0.1.0 → 非互換（MINOR差が2以上）

## リリースプロセス

### リリースフロー

```
1. 開発完了
   ↓
2. バージョン番号の決定
   ↓
3. 各ファイルのバージョン更新
   ↓
4. Gitタグの作成
   ↓
5. コミット・プッシュ
   ↓
6. CI/CDによる自動デプロイ
   ↓
7. リリース完了
```

### 詳細手順

#### 1. バージョン番号の決定

変更内容を確認し、バージョンインクリメントルールに従って新しいバージョン番号を決定します。

```bash
# 前回のリリースからの変更を確認
git log --oneline v0.1.0..HEAD

# 変更内容に基づいてバージョンを決定
# 例: 新機能追加 → 0.1.0 → 0.2.0
```

#### 2. 各ファイルのバージョン更新

決定したバージョン番号で各ファイルを更新します。

**フロントエンド:**
```bash
# frontend/package.json の version を更新
# frontend/app.json の version を更新
# frontend/app.json の versionCode/buildNumber をインクリメント（ストア提出時のみ）
```

**バックエンド:**
```bash
# backend/pyproject.toml の version を更新
```

**インフラ（必要に応じて）:**
```bash
# infra/package.json の version を更新
```

#### 3. Gitタグの作成

```bash
# アプリケーションバージョンのタグを作成
git tag -a v0.2.0 -m "Release version 0.2.0

- 新機能: 会場管理機能の追加
- 改善: 統計画面のパフォーマンス向上
- 修正: 対局登録時のバリデーションエラー"

# サブシステム別タグ（オプション）
git tag -a frontend/v0.2.0 -m "Frontend version 0.2.0"
git tag -a backend/v0.2.0 -m "Backend version 0.2.0"
git tag -a infra/v0.1.0 -m "Infrastructure version 0.1.0"
```

#### 4. コミット・プッシュ

```bash
# 変更をコミット
git add .
git commit -m "chore: bump version to 0.2.0"

# コミットとタグをプッシュ
git push origin main
git push origin --tags
```

#### 5. CI/CDによる自動デプロイ

GitHub Actionsが自動的に以下を実行します：

- バックエンドのDockerイメージビルド
- ECRへのプッシュ
- Lambda関数の更新
- フロントエンドのビルド（必要に応じて）

#### 6. リリース完了の確認

- デプロイが成功したことを確認
- `/health`エンドポイントで新しいバージョンが返されることを確認
- アプリの設定画面で新しいバージョンが表示されることを確認

### ロールバック手順

問題が発生した場合、前のバージョンにロールバックできます。

```bash
# 前のバージョンのタグを確認
git tag -l

# 前のバージョンにチェックアウト
git checkout v0.1.0

# 前のバージョンを再デプロイ
# （CI/CDまたは手動デプロイ）
```

## ビルド番号管理

モバイルアプリストア（Google Play Store、Apple App Store）への提出時に必要なビルド番号を管理します。

### ビルド番号のルール

- **Android `versionCode`**: 単調増加する整数（1, 2, 3, ...）
- **iOS `buildNumber`**: 単調増加する整数（1, 2, 3, ...）
- ストア提出時に必ずインクリメント
- セマンティックバージョンとは独立して管理

### セマンティックバージョンとビルド番号の関係

| セマンティックバージョン | ビルド番号 | 説明 |
|----------------------|----------|------|
| 0.1.0 | 1 | 初回リリース |
| 0.1.1 | 2 | バグ修正（ストア提出） |
| 0.2.0 | 3 | 新機能追加（ストア提出） |
| 0.2.0 | 4 | 同じバージョンの再ビルド（ストア提出） |
| 0.2.1 | 5 | バグ修正（ストア提出） |

### ビルド番号の更新タイミング

**ストア提出時のみインクリメント:**
- Google Play Storeへの提出時
- Apple App Storeへの提出時
- TestFlightへの提出時

**インクリメント不要:**
- 開発ビルド
- 内部テストビルド
- Expo Goでのテスト

### 更新方法

```json
// frontend/app.json
{
  "expo": {
    "version": "0.2.0",
    "android": {
      "versionCode": 3  // 前回: 2 → 今回: 3
    },
    "ios": {
      "buildNumber": "3"  // 前回: "2" → 今回: "3"
    }
  }
}
```

## ベストプラクティス

### 定期的なリリース

- **推奨サイクル**: 2週間に1回
- **緊急バグ修正**: 随時（PATCHバージョン）
- **大型機能**: 複数のMINORバージョンに分割

### 変更ログの管理

- `CHANGELOG.md`でバージョンごとの変更を記録
- GitHub Releasesで自動生成
- ユーザー向けのリリースノートを作成

### バージョン互換性の確認

- リリース前に互換性マトリクスを更新
- 破壊的変更は事前に告知
- 移行ガイドを提供

### コミュニケーション

- 破壊的変更は事前にチームに共有
- リリースノートをユーザーに通知
- バージョンアップの影響範囲を明確化

## トラブルシューティング

### バージョン不一致エラー

**症状:** フロントエンドとバックエンドのバージョンが互換性のない組み合わせ

**対応:**
1. 互換性マトリクスを確認
2. 必要に応じてフロントエンドまたはバックエンドを更新
3. ユーザーにアプリの更新を促す

### ビルド番号の重複

**症状:** ストアへの提出時にビルド番号が既に使用されている

**対応:**
1. `app.json`のビルド番号をインクリメント
2. 再ビルド
3. 再提出

### タグの誤作成

**症状:** 誤ったバージョン番号でタグを作成してしまった

**対応:**
```bash
# ローカルのタグを削除
git tag -d v0.2.0

# リモートのタグを削除
git push origin :refs/tags/v0.2.0

# 正しいタグを作成
git tag -a v0.2.0 -m "Release version 0.2.0"
git push origin v0.2.0
```

## 参考資料

- [Semantic Versioning 2.0.0](https://semver.org/)
- [Expo Versioning Guide](https://docs.expo.dev/distribution/app-stores/#versioning-your-app)
- [Python Packaging Version Specifiers](https://packaging.python.org/en/latest/specifications/version-specifiers/)
- [Git Tagging](https://git-scm.com/book/en/v2/Git-Basics-Tagging)
