# コミットメッセージ規約 - 要件書

## はじめに

Janlogプロジェクトのコミットメッセージを統一し、Conventional Commits仕様に準拠したコミットメッセージ規約を確立します。これにより、変更履歴の可読性を向上させ、自動化ツール（CHANGELOG生成、セマンティックバージョニング）との連携を可能にします。

## 用語集

- **Conventional Commits**: コミットメッセージの構造化された規約（https://www.conventionalcommits.org/）
- **コミットタイプ**: コミットの種類を示すプレフィックス（feat、fix、docsなど）
- **スコープ**: 変更の影響範囲を示す識別子（オプション）
- **破壊的変更（BREAKING CHANGE）**: 後方互換性のない変更
- **フッター**: コミットメッセージの末尾に記載する追加情報

## 要件

### 要件1: Conventional Commits準拠

**ユーザーストーリー:** 開発者として、業界標準のコミットメッセージ規約を採用したい。そうすることで、他のプロジェクトとの一貫性を保ち、ツールとの連携が容易になる。

#### 受け入れ基準

1. Janlogは、Conventional Commits 1.0.0仕様に準拠したコミットメッセージ規約を採用すること
2. コミットメッセージは、`<type>[optional scope]: <description>`の形式に従うこと
3. コミットメッセージの本文とフッターはオプションであること
4. 破壊的変更は`BREAKING CHANGE:`フッターまたは`!`接尾辞で明示すること
5. コミットメッセージは日本語で記述すること（descriptionとbody）

### 要件2: コミットタイプの定義

**ユーザーストーリー:** 開発者として、コミットの種類を明確に分類したい。そうすることで、変更履歴を理解しやすくなり、CHANGELOGの自動生成が可能になる。

#### 受け入れ基準

1. Janlogは、以下のコミットタイプを定義すること：
   - `feat`: 新機能の追加
   - `fix`: バグ修正
   - `docs`: ドキュメントのみの変更
   - `style`: コードの意味に影響しない変更（フォーマット、セミコロン等）
   - `refactor`: バグ修正や機能追加を伴わないコードの改善
   - `perf`: パフォーマンス改善
   - `test`: テストの追加・修正
   - `chore`: ビルドプロセスやツールの変更
   - `ci`: CI/CD設定の変更
   - `revert`: 以前のコミットの取り消し
2. 各コミットタイプの使用例を文書化すること
3. コミットタイプは小文字で記述すること
4. 不明確な場合のタイプ選択ガイドラインを提供すること

### 要件3: スコープの定義

**ユーザーストーリー:** 開発者として、変更の影響範囲を明確にしたい。そうすることで、どのコンポーネントが変更されたかを一目で把握できる。

#### 受け入れ基準

1. Janlogは、以下のスコープを定義すること：
   - `frontend`: フロントエンド関連の変更
   - `backend`: バックエンド関連の変更
   - `infra`: インフラストラクチャ関連の変更
   - `api`: API仕様の変更
   - `db`: データベーススキーマの変更
   - `auth`: 認証・認可関連の変更
   - `ui`: UI/UXの変更
   - `deps`: 依存関係の更新
2. スコープはオプションであり、省略可能であること
3. スコープは小文字で記述すること
4. 複数のスコープにまたがる場合は、最も影響の大きいスコープを選択すること

### 要件4: コミットメッセージの構造

**ユーザーストーリー:** 開発者として、コミットメッセージの書き方を統一したい。そうすることで、変更内容を正確に伝え、レビューやトラブルシューティングが容易になる。

#### 受け入れ基準

1. コミットメッセージのヘッダーは、50文字以内に収めること
2. コミットメッセージの本文は、72文字で改行すること
3. ヘッダーと本文の間には空行を入れること
4. 本文では、「何を」「なぜ」変更したかを説明すること
5. フッターには、関連するIssue番号やBREAKING CHANGEを記載すること

### 要件5: 破壊的変更の明示

**ユーザーストーリー:** 開発者として、後方互換性のない変更を明確に示したい。そうすることで、他の開発者やユーザーに影響を事前に伝えられる。

#### 受け入れ基準

1. 破壊的変更を含むコミットは、`BREAKING CHANGE:`フッターを含むこと
2. 破壊的変更を含むコミットは、タイプの後に`!`を付けることができること（例: `feat!:`）
3. `BREAKING CHANGE:`フッターには、変更内容と移行方法を記載すること
4. 破壊的変更は、MAJORバージョンのインクリメントをトリガーすること

### 要件6: コミットメッセージのバリデーション

**ユーザーストーリー:** 開発者として、コミットメッセージが規約に準拠しているか自動的にチェックしたい。そうすることで、規約違反を防ぎ、一貫性を保てる。

#### 受け入れ基準

1. Janlogは、コミットメッセージのバリデーションツールを導入すること
2. バリデーションは、Git hooksを使用してコミット時に自動実行されること
3. バリデーションエラーが発生した場合、コミットを拒否すること
4. バリデーションエラーメッセージには、修正方法を含めること
5. バリデーションルールは、`.commitlintrc.json`で設定可能であること

### 要件7: ドキュメント化

**ユーザーストーリー:** 開発者として、コミットメッセージ規約を参照できるドキュメントが欲しい。そうすることで、新しいメンバーも規約を理解しやすくなる。

#### 受け入れ基準

1. Janlogは、プロジェクトルートに`COMMIT_CONVENTION.md`ドキュメントを作成すること
2. `COMMIT_CONVENTION.md`は、Conventional Commitsの概要を説明すること
3. `COMMIT_CONVENTION.md`は、各コミットタイプとスコープの使用例を含むこと
4. `COMMIT_CONVENTION.md`は、良い例と悪い例を示すこと
5. `COMMIT_CONVENTION.md`は、破壊的変更の記述方法を説明すること
6. `README.md`から`COMMIT_CONVENTION.md`へのリンクを追加すること

### 要件8: 既存コミット履歴の扱い

**ユーザーストーリー:** 開発者として、既存のコミット履歴をどう扱うか明確にしたい。そうすることで、過去のコミットとの整合性を保てる。

#### 受け入れ基準

1. 既存のコミット履歴は変更しないこと（rebaseやamendは行わない）
2. 新しい規約は、規約導入後のコミットから適用すること
3. 規約導入のタイミングを`COMMIT_CONVENTION.md`に記載すること
4. 過去のコミットを参照する場合は、規約に準拠していない可能性があることを認識すること
